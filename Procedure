//////////////////////////Proecedures/////////////////////////////////////////////////////

The Stored Procedure is compile and read the data for re use purpose.
The objects inside the own of the procedure is _SYS_REPO.

The INVOKER and DEFINER...
When we create the procedure the owner of the procedure is _SYS_REPO, When any of the user in system is invoking the Procedure by default the invoking of the procedure 
has to be done with the _SYS_REPO then you define Authorization as Definer.

When ever the procedure is called, if the Procedure call should has to happen with the user authorization who defind that procedure then you can use the Invoker.
SELECT * from Procedure where procedure_name like '%Add%';

In the table type table, the column names all converted to uppercase even if it is lower case defind it will convert to upper case.
FROM HANA 2.0 onwards the SAP HANA supports the inserting of the records in the table type tables also, we have to use the 
like the below syntax we can use for the delete and update on the table type table.
syntax :table type table.Insert(followed columns, index)----Here the index indicates the row number which it is inserted the records in table.


PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CALLOTHER" (in in_number INteger, 
out results table(mul integer)) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
declare lv_count integer;
declare ind integer := 1;
for ind in 1..:in_number DO
	:results.insert((:ind*10),ind);
end for;
END;
------------------------------------------Simple Hello World-------------------
PROCEDURE "PRACTICE_BATCHONE::Procedure_Example" ( ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	READS SQL DATA AS
BEGIN
select 'Hello World' from Dummy;
END;
call "PRACTICE_BATCHONE::Procedure_Example" ( )
------------------------------------------------Declaring Variable and reading the data-----------------
PROCEDURE "PRACTICE_BATCHONE::Procedure_Assign" ( ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE V_VAL INTEGER;
V_VAL := 10;
select :V_VAL from Dummy;
END;
call "PRACTICE_BATCHONE::Procedure_Example" ( )

--------------------------------------------------------Reading the input value at run time and do calculation-----------------------
PROCEDURE "PRACTICE_BATCHONE::Procedure_Example" (IN V_VAL1 INT, IN V_VAL2 INT) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE V_SUM INTEGER;
V_SUM := :V_VAL1+ :V_VAL2;
select :V_SUM from Dummy;
END;

--call "PRACTICE_BATCHONE::Procedure_Example" (10,20);
--call "PRACTICE_BATCHONE::Procedure_Example" (V_VAL1=>50, V_VAL2=>20 );
--call "PRACTICE_BATCHONE::Procedure_Example" (V_VAL2=>50, V_VAL1=>20 );

-------------------------------------------------------  Declaring the Output Parameter-------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne" 
(IN V_VAL1 INT, IN V_VAL2 INT, out V_SUM INTEGER) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	READS SQL DATA AS
BEGIN
/*---DECLARE V_SUM INTEGER;---*/
V_SUM := :V_VAL1+ :V_VAL2;
select :V_SUM from Dummy;
END;
call  "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"(10,20,?)

------------------------------------Declaring multiple Output Parameters-----------------------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne" 
(IN V_VAL1 INT, IN V_VAL2 INT, out V_SUM INTEGER,out V_SUB INTEGER) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	READS SQL DATA AS
BEGIN
/*---DECLARE V_SUM INTEGER;---*/
V_SUM := :V_VAL1+ :V_VAL2;
V_SUB := :V_VAL1- :V_VAL2;
select :V_SUM from Dummy;
END;
call  "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"(10,20,?,?)

-----------------------------------------------Calling procedure inside another procedure-------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CALLOTHER" ( ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE RESULTVAL INTEGER;
call  "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"(10,20,V_SUM=>:RESULTVAL);
select :RESULTVAL from dummy;
END;

call "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CALLOTHER" ( ) 

------------------------------------------Reading the table data----------------------------------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CALLOTHER" ( ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
 
LT_DATA = SELECT "PRODUCT_ID", "PRODUCT_TYPE", "PRODUCT_NAME", "CATEGORY"
		  FROM "PRACTICE_BATCHONE"."Prdoucts";
		  
	  SELECT * from :LT_DATA;
END;

--------------------------------------------REaading table data with output structure pointing local table data------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CALLOTHER" ( out LT_Data "PRACTICE_BATCHONE"."Prdoucts") 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
 
LT_Data = SELECT "PRODUCT_ID", "PRODUCT_TYPE", "PRODUCT_NAME", "CATEGORY"
		  FROM "PRACTICE_BATCHONE"."Prdoucts";
		  
		 select * from :LT_Data;
END;

--------------------------------------------Reaading table data with output structure pointing table type table ------------------


PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CALLOTHER" ( out LT_Data "PRACTICE_BATCHONE"."TT_DATA") 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
 
LT_Data = SELECT "PRODUCT_ID", "PRODUCT_TYPE", "PRODUCT_NAME", "CATEGORY"
		  FROM "PRACTICE_BATCHONE"."Prdoucts";
		  
		 select * from :LT_Data;
END;

The Table type table should always has the same naming convention as the select statement, If the select column names are different then what we have defind in table type 
then you should have as and point that name

--------------------------------------------------Reading data with IN and OUT parameter-----------------------------------------

PROCEDURE "PRACTICE_BATCHONE::Proc_SimpleOne" 
(INOUT V_VAL INT) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	READS SQL DATA AS
BEGIN
V_VAL := :V_VAL+20;
END;
-----------------------------------------------------IF and ELSE Proce--------------------------------

PROCEDURE "PRACTICE_BATCHONE::Proc_SimpleOne" 
(IN LV_OPTION VARCHAR(100), IN V_VAL1 INT, IN V_VAL2 INT, OUT RESULT_VAL INTEGER ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
IF :LV_OPTION = 'ADD' THEN
	RESULT_VAL:= :V_VAL1+ :V_VAL2;
		ELSE IF :LV_OPTION = 'SUB' THEN
	RESULT_VAL:= :V_VAL1-:V_VAL2;
		ELSE IF :LV_OPTION = 'MUL' THEN
	RESULT_VAL:= :V_VAL1*:V_VAL2;
		ELSE
		RESULT_VAL:= :V_VAL1/:V_VAL2;
END IF;		
END;

---------------------------------------------calculating the new taxes based on the  values------------------------
PROCEDURE "PRACTICE_BATCHONE::Proc_SimpleOne" 
(out out_data "PRACTICE_BATCHONE"."TAX_CL" ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
lt_data = select "CUSTER_ID","PAYMENT_TYPE","SALESREP_ID","TOTALAMOUNT", 
           CASE "CUSTER_ID" 
           WHEN 100 THEN "TOTALAMOUNT"*0.2
           WHEN 110 THEN "TOTALAMOUNT"*0.4 end as "TAX_VAL"  from "PRACTICE_BATCHONE"."SALES_ORDER";
out_data =select * from :lt_data;
END;
condition statements are If and case only and if can be used in conditional executions.
Note : -The Case statement should only be used in the select statement and it' can't be used in any other statements. 

----------------------------------------------------For Loop Proceddure--------------------------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"() 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE LV_COUNT INTEGER := 1;
FOR LV_COUNT IN 1.. 4
DO
select :LV_COUNT from dummy;
END FOR;
END;

--------------------------------------------------------While Loop Procedure---------------------------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"() 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE LV_COUNT INTEGER := 4;
DECLARE LV_CNT INTEGER :=1;
		WHILE :LV_CNT<:LV_COUNT DO
		SELECT :LV_CNT from dummy;
		LV_CNT := :LV_CNT+1;
		END WHILE;
END;

----------------------------------------------Break In Procedure-----------------------------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"() 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE LV_LOOP INTEGER := 3;
DECLARE LV_COUNT INTEGER :=1;
		LOOP
		SELECT :LV_COUNT from dummy;
		IF :LV_COUNT>= :LV_LOOP THEN
		BREAK;
		END IF;
		LV_COUNT := :LV_COUNT+1;
		END LOOP;
END;
-------------------------------------------------------------------------CURSOR-----------------------------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::Proc_SimpleOne"() 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	 AS
BEGIN
DECLARE LV_ROWCOUNT INTEGER;
DECLARE LV_COUNT INTEGER :=0;
DECLARE LV_CUSTERID INTEGER;
DECLARE LV_NAME NVARCHAR(200);
DECLARE LV_PHONENUMBER NVARCHAR(200);
DECLARE CURSOR CURSOR_A FOR SELECT * FROM "PRACTICE_BATCHONE"."Customer";

CREATE LOCAL TEMPORARY table #TEST(CUSTERID INTEGER,NAMEs NVARCHAR(200),PHONENUMBER NVARCHAR(200));
SELECT COUNT(*) INTO LV_ROWCOUNT from "PRACTICE_BATCHONE"."Customer";

OPEN CURSOR_A;
		LOOP
			IF :LV_COUNT< :LV_ROWCOUNT THEN 
		    FETCH CURSOR_A INTO LV_CUSTERID,LV_NAME,LV_PHONENUMBER;
		    LV_COUNT := :LV_COUNT+1;
		    ELSE
		    CLOSE CURSOR_A;
			BREAK;
			END IF;
			END LOOP;
	INSERT INTO #TEST VALUES(LV_CUSTERID,LV_NAME,LV_PHONENUMBER);
	
	SELECT * from #TEST;
	DROP TABLE #TEST;

END;
------------------------------------------------------------------------CURSOR TO DELETE RECORD BY RECORD-----------------------------------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_CURSOR" ( ) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
 AS
BEGIN

DECLARE CURSOR CUSTOMER_CUR FOR 
SELECT * FROM  "PRACTICE_BATCHONE"."TEMP_CUST";

FOR CUR_CUST as CUSTOMER_CUR DO
     IF CUR_CUST.CUSTER_ID<200 THEN
        DELETE FROM "PRACTICE_BATCHONE"."TEMP_CUST" where "CUSTER_ID" = CUR_CUST.CUSTER_ID;
     END IF;
END FOR;
END;

----------------------------------------------------------------------------DYNAMIC SQL IN PROCEDURE---------------------------------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" ( IN LV_TABLE NVARCHAR(2000)) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	READS SQL DATA AS
BEGIN
DECLARE LV_SQL VARCHAR(200);

SELECT CONCAT('SELECT * FROM',:LV_TABLE) INTO LV_SQL from dummy;
EXECUTE IMMEDIATE :LV_SQL;
END;

 call "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL"('"PRACTICE_BATCHONE"."Address"');
 
-----------------------------------------------------------------PAssing the Values to Procedure------------------------------------------------  
 PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" ( IN LV_NUMBER INTEGER) 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	READS SQL DATA AS
BEGIN
DECLARE LV_SQL VARCHAR(200);

SELECT CONCAT('SELECT * FROM WHERE CUSTOMER_ID>=',:LV_TABLE) INTO LV_SQL from dummy;
EXECUTE IMMEDIATE :LV_SQL;
END;
call "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL"('205')

------------------------------------------------------------Arrays In Procedure------------------------------------------------------------------------
----------------------------One-----------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" () 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	AS
BEGIN
DECLARE A NVARCHAR(200) ARRAY;
A[1] := 'Prasad';
SELECT :A[1] from DUMMY;
END;
------------------------------------------------------------------Declareing an Array and assigning values to an Array--------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" () 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	AS
BEGIN
DECLARE A NVARCHAR(200) ARRAY:= ARRAY('Vara','Prasad','Puram');
SELECT :A[3] from DUMMY;
END;
-----------------------------------------------------------Declaring array and unnsetting the arrays data------------------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" () 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	AS
BEGIN
DECLARE A NVARCHAR(200) ARRAY:= ARRAY('Vara','Prasad','Puram');
tab1 =  unnest(:A);
select * from :tab1;
END;

PROCEDURE "build_product_list" (
   out ex_products "Procedures.tt_product_sale_price" )
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   --DEFAULT SCHEMA <default_schema_name>
   READS SQL DATA AS
BEGIN
   /*************************************
       Write your procedure logic 
   *************************************/
  declare productid nvarchar(10) ARRAY;
  declare category nvarchar(40) ARRAY;
  declare price decimal(15,2) ARRAY;
  declare saleprice decimal(15,2) ARRAY;
 
  productid[1] := 'ProductA';
  productid[2] := 'ProductB';
  productid[3] := 'ProductC';
    
  category[1] := 'CategoryA';
  category[2] := 'CategoryB';
  category[3] := 'CategoryC';
   
  price[1] := 19.99;
  price[2] := 29.99;
  price[3] := 39.99;
    
  saleprice[1] := 15.99;
  saleprice[2] := 25.99;
  saleprice[3] := 35.99;
 
  ex_products = unnest(:productId, :category, :price, :saleprice) 
                    as ("PRODUCTID", "CATEGORY", "PRICE", "SALEPRICE");

END;
------------------------------------------Converting the table data column into an Array format--------------------------------
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" () 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	AS
BEGIN
DECLARE LV_STATE NVARCHAR(200) ARRAY;
tabledata = SELECT * from "PRACTICE_BATCHONE"."Address";
LV_STATE:= ARRAY_AGG(:tabledata."STATE");

SELECT :LV_STATE[2] from DUMMy;


END;
-------------------------------------------------------------------DECLARE EXIST HANDLERS TO CATCH EXCEPTION-------------------------------

PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" () 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	AS
BEGIN
DECLARE LV_COUNT INTEGER;

DECLARE CUSTOMCONDITION CONDITION FOR  SQL_ERROR_CODE 10001;
DECLARE EXIT HANDLER FOR CUSTOMCONDITION

SELECT ::SQL_ERROR_CODE as "Error_Code", ::SQL_ERROR_MESSAGE as "Error_Message" from DUMMY;

SELECT COUNT(*) INTO LV_COUNT FROM  "PRACTICE_BATCHONE"."SCENARIO2";

IF LV_COUNT =0 THEN

SIGNAL CUSTOMCONDITION SET MESSAGE_TEXT ='No data found in the table';
END IF;

END;

==================================================Other Way of Handling the Exceptions in SAP HANA===================================================
PROCEDURE "PRACTICE_BATCHONE"."PRACTICE_BATCHONE::PROC_DYNAMIC_SQL" () 
	LANGUAGE SQLSCRIPT
	SQL SECURITY INVOKER 
	--DEFAULT SCHEMA <default_schema_name>
	AS
BEGIN
DECLARE LV_COUNT INTEGER;

DECLARE CUSTOMCONDITION CONDITION FOR  SQL_ERROR_CODE 10001;
DECLARE EXIT HANDLER FOR CUSTOMCONDITION
BEGIN
SELECT ::SQL_ERROR_CODE as "Error_Code", ::SQL_ERROR_MESSAGE as "Error_Message" from DUMMY;
END;

SELECT COUNT(*) INTO LV_COUNT FROM  "PRACTICE_BATCHONE"."SCENARIO2";

IF LV_COUNT=0 THEN

SIGNAL CUSTOMCONDITION SET MESSAGE_TEXT = 'Input parameter can not be empty';  
END IF;

END;










Create procedure "PRACTICE_BATCHONE".SALES_PROC()
Language sqlscript 
SQL security invoker 
as
Begin
/*********begin procedure script ************/
SELECT  C."CUSTER_ID", "NAME", "PHONENUMBER","STATE", "COUNTRY", "REGION"
				FROM "PRACTICE_BATCHONE"."Customer" as C inner join 
				"PRACTICE_BATCHONE"."Address" as A
				on C."CUSTER_ID" = A."CUSTER_ID";
				
	
	
end;
---------------------------------------------------------------------------------
PROCEDURE "get_po_header_data" ( IN in_state Varchar(100), IN in_country varchar(100), 
out ex_error  nvarchar(100)
)
   LANGUAGE SQLSCRIPT
   SQL SECURITY INVOKER
   --DEFAULT SCHEMA <default_schema_name>
 AS
BEGIN
DECLARE noc Integer;

select count(*) INTO noc from "Cust_Info" where  "STATE" = :in_state AND "COUNTRY" = :in_country;

IF :noc>=1 then 
ex_error = 'ERROR: Content'||' '||:in_state ||' '||:in_country || 'Country is exist';
else 
INSERT INTO "Cust_Info" values(:in_state,:in_country);
End if;
end;	



